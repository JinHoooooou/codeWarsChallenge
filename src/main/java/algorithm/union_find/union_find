# Union-Find

## 1. Disjoint-Set 

* 서로 **중복되지 않는 부분 집합**에 대한 자료구조
  * **서로소 집합 자료구조**, 공통 원소가 없는 '상호 베타적'인 부분집합에 대한 자료구조


## 2. Union-Find 알고리즘

### 2-1. Union-Find 개념
* Disjoint-Set 자료구조를 표현할 때 사용하는 알고리즘
    * 집합을 구현할 떄 벡터, 배열, 연결 리스트 등을 사용할 수 있지만, 가장 효율적인 트리구조로 표현한다.

### 2-2. Union-Find 연산
* Make-Set(x)
    * 초기화 연산
    * x자신을 root로 하는 집합을 만든다.
* Union(from, to)
    * 두 원소를 하나의 집합으로 합치는 연산
    * to가 속한 집합을 from이 속한 집합으로 합친다.
* Find(x)
    * root를 찾는 연산
    * x원소가 속하는 집합의 root 원소를 찾는다.
 
 ### 2-3. 구현 방법
 1. Array
    * arr[i] : i번 원소의 root 원소
    * Make-Set(x)
        * arr[i] = i로 초기화
    * Union(from, to)
        * 배열을 순회하면서 to가 속한 집합을 from이 속한 집합으로 합친다.
        * 시간 복잡도 : O(n)
    * Find(x)
        * 한 번에 x가 속한 집합의 root 원소를 찾는다.
        * 시간 복잡도 : O(1)
 2. Tree
    * 같은 집합 == 하나의 트리
    * Make-Set(x)
        * 각 노드는 모두 root 노드이므로 n개의 root 노드 생성 및 자기 자신으로 초기화
    * Union(from, to)
        * from과, to의 root 노드를 찾고, 서로 다르다면 to를 from의 자손으로 넣어 두 트리를 합한다.
        * 시간 복잡도 : O(n)보다 작으므로, find(x) 연산이 전체 수행 시간을 지배한다.
    * find(x)
        * 노드의 번호는 root 노드를 뜻하므로, 루트 노드를 확인하여 같은 집합인지 확인한다.
        * 시간 복잡도 : 트리의 높이와 시간 복잡도가 동일하다.
            * 최악의 경우 O(n-1)
 
 ## 3. Union-Find 사용 예시
 전체 집합이 있을 때 구성 원소들이 겹치지 않도록 분할(partition)하는 데 자주 사용된다.
 * Kruskal 알고리즘에서 새로 추가할 간선의 양 끝 정점이 같은 집합에 속해 있는지(사이클 여부 확인)에 대해 검사하는 경우
 * 초기에 {0}, {1}, {2}, ..., {n}이 각 n+1개의 집합을 이루고 있을 때, 합집합 연산과 두 원소가 같은 집합에 포함되어 있는지 검사하는 경우
 
 ## 4. Union-Find의 구현 방법
 ### 4-1. 기본적인 구현 방법
 ```java
public class DisjointSet{ 
  
  int[] root;
  int n = size;

  /* Make-Set(x) */
  public DisjointSet() {
    root = new int[n];
    for(int i = 0; i<n;i++) {
      root[i] = i;
    }
  }

  /* Find(x) */
  public int find(int x) {
    if(root[x] == x) {
      return x;
    }
    return find(root[x]);
  }

  /* Union(from, to) */
  public void union(int from, int to) { 
    from = find(from);
    to = find(to);

    root[to] = from;
  }
}
```

### 4-2. 최적화된 구현 방법
* 최악의 경우
    *  3 👉 5 👉 7 👉 1 👉 8 👉 9 👉 4 👉 6 👉 2 같이 연결 리스트의 경우 트리의 높이가 n-1이 된다.
* find(x) 최적화
```java
int find(int x) {
  if(root[x] == x) {
    return x;
  }
  return root[x] = find(root[x]);
}
```    
* 경로 압축(path compression) : find(x)하면서 만난 모든 노드의 root를 교체한다.
* 시간 복잡도 : O(logn)

* union(from, to) 최적화
```java
int[] root
int[] rank // 트리의 높이를 저장할 배열

void union(int x, int y) { 
  x = find(x);
  y = find(y);
  
  if(x==y) {
    return;
  }
  
  if(rank[x] < rank[y]) {
    root[x] = y;
  } else {
    root[y] = x;
  }

  if(rank[x] == rank[y]) {
    rank[x]++;
  }
}
```
* union-by-height
* rank에 각 트리의 높이를 저장한다.
* 항상 더 낮은 트리가 높은 트리 밑으로 들어간다.
                       